import cv2
import mediapipe as mp
import numpy as np
import time  # Add time for debugging timestamps

class HandGestureDetector:
    """Class to detect hand gestures and convert them to car control signals 
    according to the SRS specifications."""
    
    def __init__(self):
        """Initialize the hand gesture detector with MediaPipe."""
        self.mp_hands = mp.solutions.hands
        self.hands = self.mp_hands.Hands(
            static_image_mode=False,
            max_num_hands=1,  # Track only one hand for simplicity
            min_detection_confidence=0.5,  # Reduced for better detection rate
            min_tracking_confidence=0.5    # Better tracking
        )
        self.mp_draw = mp.solutions.drawing_utils
        self.mp_drawing_styles = mp.solutions.drawing_styles
        
        # Control state with improved smoothing
        self.prev_steering = 0
        self.prev_throttle = 0
        self.steering_smoothing = 0.5  # Balanced value for stable but responsive steering
        self.throttle_smoothing = 0.4  # Slightly faster response for throttle
        
        # State tracking for gesture stability
        self.gesture_history = []
        self.history_size = 5
        self.last_command = None
        self.command_stability_count = 0
        self.stability_threshold = 3  # Require this many consistent readings
        
        # Debug and display options
        self.debug_mode = True
        self.last_log_time = time.time()
        self.log_interval = 2.0  # Log every 2 seconds
        
        # Fallback controls in case of detection issues
        self.fallback_controls = {
            'steering': 0.0,
            'throttle': 0.0,
            'braking': False,
            'boost': False,
            'gesture_name': 'Fallback controls',
            'speed': 0.0,
            'direction': 0.0
        }
        
        print("üñêÔ∏è Hand gesture detector initialized - v2.0 with improved reliability")
        
    def ensure_valid_frame(self, frame):
        """Ensure we have a valid frame to process"""
        if frame is None:
            print("‚ö†Ô∏è Warning: Received None frame, using blank frame instead")
            return np.zeros((480, 640, 3), dtype=np.uint8)
        
        # Check if frame is grayscale and convert to BGR if needed
        if len(frame.shape) == 2 or (len(frame.shape) == 3 and frame.shape[2] == 1):
            print("‚ö†Ô∏è Warning: Received grayscale frame, converting to BGR")
            return cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)
            
        # Check if frame is too small
        if frame.shape[0] < 10 or frame.shape[1] < 10:
            print(f"‚ö†Ô∏è Warning: Frame too small {frame.shape}, using blank frame")
            return np.zeros((480, 640, 3), dtype=np.uint8)
            
        return frame
        
    def detect_gestures(self, frame):
        """
        Detect hand gestures in the given frame and return control signals.
        
        Args:
            frame: CV2 image frame
            
        Returns:
            controls: Dictionary with control values
            processed_frame: Frame with visualization
        """
        try:
            # Ensure we have a valid frame
            frame = self.ensure_valid_frame(frame)
            
            # Periodic debugging
            current_time = time.time()
            if current_time - self.last_log_time > self.log_interval:
                self.last_log_time = current_time
                print(f"üñêÔ∏è Hand detector processing frame: shape={frame.shape}")
            
            # Flip the frame horizontally for more natural interaction
            frame = cv2.flip(frame, 1)
            
            # Convert BGR to RGB
            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            
            # Process the frame with MediaPipe
            results = self.hands.process(rgb_frame)
            
            # Default controls
            controls = {
                'steering': 0.0,     # -1.0 (full left) to 1.0 (full right)
                'throttle': 0.0,     # 0.0 to 1.0
                'braking': False,
                'boost': False,
                'gesture_name': 'No hand detected'
            }
            
            # Draw hand landmarks and extract control information
            if results.multi_hand_landmarks:
                for hand_landmarks in results.multi_hand_landmarks:
                    # Draw hand landmarks on the frame
                    self.mp_draw.draw_landmarks(
                        frame,
                        hand_landmarks,
                        self.mp_hands.HAND_CONNECTIONS,
                        self.mp_drawing_styles.get_default_hand_landmarks_style(),
                        self.mp_drawing_styles.get_default_hand_connections_style()
                    )
                    
                    # Extract control values from hand landmarks
                    controls = self._extract_controls_from_landmarks(hand_landmarks, frame, controls)
                    
                    # Log detected gestures at intervals
                    if current_time - self.last_log_time > self.log_interval:
                        print(f"üëã Detected gesture: {controls['gesture_name']}, " +
                              f"Steering: {controls['steering']:.2f}, " +
                              f"Throttle: {controls['throttle']:.2f}")
            else:
                # Reset stability counter when no hand detected
                self.command_stability_count = 0
                
            # Add visualization of current controls to the frame
            self._add_control_visualization(frame, controls)
            
            # Add speed and direction mappings for compatibility with the Car class
            controls['speed'] = controls['throttle']
            controls['direction'] = controls['steering']
            
            return controls, frame
            
        except Exception as e:
            print(f"Error in gesture detection: {e}")
            import traceback
            traceback.print_exc()
            # Return the fallback controls to ensure the car still gets input
            return self.fallback_controls, frame
    
    def _extract_controls_from_landmarks(self, landmarks, frame, controls):
        """
        Extract control values from hand landmarks according to SRS specs:
        - Steering: hand tilt for left/right
        - Throttle: hand height for speed
        - Brake: fist gesture
        - Boost: thumb up, other fingers curled
        - Stop: open palm
        """
        # Convert landmarks to more accessible format
        h, w, c = frame.shape
        landmark_points = []
        for lm in landmarks.landmark:
            x, y = int(lm.x * w), int(lm.y * h)
            landmark_points.append((x, y))
        
        # Get key points
        wrist = landmark_points[0]
        thumb_tip = landmark_points[4]
        index_tip = landmark_points[8]
        middle_tip = landmark_points[12]
        ring_tip = landmark_points[16]
        pinky_tip = landmark_points[20]
        
        # Get MCP (knuckle) positions for detecting finger curling
        thumb_mcp = landmark_points[2]
        index_mcp = landmark_points[5]
        middle_mcp = landmark_points[9]
        ring_mcp = landmark_points[13]
        pinky_mcp = landmark_points[17]
        
        # ==================== STEERING DETECTION ====================
        dx = thumb_tip[0] - wrist[0]
        dy = thumb_tip[1] - wrist[1]
        
        thumb_angle = np.degrees(np.arctan2(-dy, dx))
        if thumb_angle < 0:
            thumb_angle += 360
        
        if 80 <= thumb_angle <= 100:
            raw_steering = 0.0
        elif thumb_angle < 80:
            if thumb_angle < 45:
                raw_steering = 1.0
            else:
                raw_steering = 0.3 + 0.7 * (80 - thumb_angle) / 35
        elif thumb_angle > 100:
            if thumb_angle > 135:
                raw_steering = -1.0
            else:
                raw_steering = -0.3 - 0.7 * (thumb_angle - 100) / 35

        steering = self.prev_steering * self.steering_smoothing + raw_steering * (1 - self.steering_smoothing)
        steering = max(-1.0, min(1.0, steering))
        self.prev_steering = steering
        controls['steering'] = steering
        
        if self.debug_mode:
            center = (wrist[0], wrist[1])
            radius = 50
            cv2.ellipse(frame, center, (radius, radius), 0, -100, -80, (0, 255, 255), 2)
            cv2.ellipse(frame, center, (radius, radius), 0, -80, -45, (0, 255, 0), 2)
            cv2.ellipse(frame, center, (radius, radius), 0, -135, -100, (0, 0, 255), 2)
            
            angle_rad = np.radians(-thumb_angle)
            end_point = (
                int(center[0] + radius * np.cos(angle_rad)),
                int(center[1] + radius * np.sin(angle_rad))
            )
            cv2.line(frame, center, end_point, (255, 255, 255), 2)
            
            cv2.putText(frame, f"Thumb: {thumb_angle:.1f}¬∞", (10, 30), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
            cv2.putText(frame, f"Steering: {raw_steering:.2f}", (10, 60), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
        
        # ==================== THROTTLE DETECTION ====================
        normalized_y = 1.0 - (wrist[1] / h)
        raw_throttle = normalized_y ** 1.5
        
        throttle = self.prev_throttle * self.throttle_smoothing + raw_throttle * (1 - self.throttle_smoothing)
        throttle = max(0.0, min(1.0, throttle))
        self.prev_throttle = throttle
        controls['throttle'] = throttle
        
        # ==================== GESTURE DETECTION ====================
        index_curled = self._is_finger_curled(index_tip, index_mcp, wrist)
        middle_curled = self._is_finger_curled(middle_tip, middle_mcp, wrist)
        ring_curled = self._is_finger_curled(ring_tip, ring_mcp, wrist)
        pinky_curled = self._is_finger_curled(pinky_tip, pinky_mcp, wrist)
        
        # ◊ë◊ì◊ô◊ß◊î ◊û◊©◊ï◊§◊®◊™ ◊©◊ú ◊î◊ê◊í◊ï◊ì◊ú
        thumb_extended = self._is_thumb_extended_improved(thumb_tip, thumb_mcp, wrist)
        thumb_curled = not thumb_extended
        
        # ◊ó◊ô◊©◊ï◊ë ◊î◊û◊®◊ó◊ß ◊ë◊ô◊ü ◊î◊ê◊í◊ï◊ì◊ú ◊ú◊ê◊¶◊ë◊¢ ◊î◊û◊ï◊®◊î - ◊°◊ô◊û◊ü ◊û◊ï◊ë◊î◊ß ◊©◊î◊ê◊í◊ï◊ì◊ú ◊ê◊ô◊†◊ï ◊ó◊ú◊ß ◊û◊ê◊í◊®◊ï◊£
        thumb_to_index_dist = np.sqrt((thumb_tip[0] - index_tip[0])**2 + (thumb_tip[1] - index_tip[1])**2)
        index_to_middle_dist = np.sqrt((index_tip[0] - middle_tip[0])**2 + (index_tip[1] - middle_tip[1])**2)
        
        # ◊î◊ê◊í◊ï◊ì◊ú ◊®◊ó◊ï◊ß ◊û◊©◊û◊¢◊ï◊™◊ô◊™ ◊û◊î◊ê◊¶◊ë◊¢ ◊î◊û◊ï◊®◊î ◊ë◊ô◊ó◊° ◊ú◊û◊®◊ó◊ß ◊ë◊ô◊ü ◊î◊ê◊¶◊ë◊¢◊ï◊™ ◊î◊ê◊ó◊®◊ï◊™
        thumb_clearly_separated = thumb_to_index_dist > 2 * index_to_middle_dist
        
        # ◊û◊®◊ó◊ß ◊û◊û◊ï◊¶◊¢ ◊ë◊ô◊ü ◊ß◊¶◊ï◊™ ◊î◊ê◊¶◊ë◊¢◊ï◊™
        tip_points = [index_tip, middle_tip, ring_tip, pinky_tip]
        avg_distance = 0
        count = 0
        for i in range(len(tip_points)):
            for j in range(i+1, len(tip_points)):
                dist = np.sqrt((tip_points[i][0] - tip_points[j][0])**2 + 
                              (tip_points[i][1] - tip_points[j][1])**2)
                avg_distance += dist
                count += 1
        
        if count > 0:
            avg_distance /= count
            
        # ◊û◊®◊ó◊ß ◊ë◊ô◊ü ◊§◊ô◊ß◊ï◊™ ◊î◊ê◊¶◊ë◊¢◊ï◊™ (◊û◊§◊®◊ß◊ô◊ù) - ◊ú◊û◊ì◊ô◊ì◊î ◊ô◊ó◊°◊ô◊™
        mcp_points = [index_mcp, middle_mcp, ring_mcp, pinky_mcp]
        mcp_distance = 0
        count = 0
        for i in range(len(mcp_points)):
            for j in range(i+1, len(mcp_points)):
                dist = np.sqrt((mcp_points[i][0] - mcp_points[j][0])**2 + 
                              (mcp_points[i][1] - mcp_points[j][1])**2)
                mcp_distance += dist
                count += 1
        
        if count > 0:
            mcp_distance /= count
        
        # ◊ê◊í◊®◊ï◊£ ◊û◊ñ◊ï◊î◊î ◊®◊ß ◊ê◊ù ◊õ◊ú 5 ◊î◊ê◊¶◊ë◊¢◊ï◊™ ◊û◊õ◊ï◊§◊§◊ï◊™ (◊õ◊ï◊ú◊ú ◊î◊ë◊ï◊î◊ü) ◊ï◊í◊ù ◊ß◊¶◊ï◊™ ◊î◊ê◊¶◊ë◊¢◊ï◊™ ◊ß◊®◊ï◊ë◊ô◊ù ◊ñ◊î ◊ú◊ñ◊î
        # ◊ï◊î◊ï◊°◊§◊™ ◊™◊†◊ê◊ô - ◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊ë◊ï◊ú◊ò ◊î◊ó◊ï◊¶◊î ◊ë◊¶◊ï◊®◊î ◊ë◊®◊ï◊®◊î, ◊ñ◊î ◊ú◊ê ◊ê◊í◊®◊ï◊£!
        fingers_close_to_each_other = avg_distance < mcp_distance * 0.8
        all_fingers_curled = index_curled and middle_curled and ring_curled and pinky_curled
        fist_detected = fingers_close_to_each_other and all_fingers_curled and thumb_curled and not thumb_clearly_separated

        # ◊ô◊ì ◊§◊™◊ï◊ó◊î - ◊ë◊ì◊ô◊ß◊î ◊©◊î◊ê◊¶◊ë◊¢◊ï◊™ ◊û◊®◊ï◊ó◊ß◊ï◊™ ◊ñ◊ï ◊û◊ñ◊ï ◊ï◊í◊ù ◊®◊ï◊ë◊ü ◊ú◊ê ◊û◊õ◊ï◊§◊§◊ï◊™
        fingers_far_from_each_other = avg_distance > mcp_distance * 1.2
        extended_fingers_count = 4 - sum([index_curled, middle_curled, ring_curled, pinky_curled])  # ◊û◊õ◊ú 4 ◊î◊ê◊¶◊ë◊¢◊ï◊™ (◊ú◊ú◊ê ◊î◊ê◊í◊ï◊ì◊ú)
        open_palm = fingers_far_from_each_other and extended_fingers_count >= 3 and not fist_detected
        
        # ◊¢◊ì◊ô◊§◊ï◊™ ◊ú◊î◊ó◊ú◊ò◊ï◊™ - ◊ê◊í◊®◊ï◊£ ◊û◊†◊¶◊ó ◊õ◊£ ◊ô◊ì ◊§◊™◊ï◊ó◊î ◊ë◊û◊ß◊®◊î ◊©◊ú ◊°◊§◊ß
        if fist_detected and not open_palm:
            controls['gesture_name'] = 'Brake (Fist)'
            controls['braking'] = True
            controls['throttle'] = 0.0
            controls['boost'] = False
            self._update_command_stability("BRAKE")
        elif open_palm and not fist_detected:
            controls['gesture_name'] = 'Stop (Open Palm)'
            controls['braking'] = True
            controls['throttle'] = 0.0
            controls['boost'] = False
            self._update_command_stability("STOP")
        elif thumb_extended:
            controls['gesture_name'] = 'Boost (Thumb Up)'
            controls['boost'] = True
            controls['braking'] = False
            controls['throttle'] = 1.0
            self._update_command_stability("BOOST")
        else:
            if abs(steering) > 0.3:
                if steering < -0.3:
                    controls['gesture_name'] = 'Turning Left'
                    self._update_command_stability("LEFT")
                else:
                    controls['gesture_name'] = 'Turning Right'
                    self._update_command_stability("RIGHT")
            else:
                controls['gesture_name'] = 'Forward'
                self._update_command_stability("FORWARD")
                
        # ◊î◊ï◊°◊§◊™ ◊ì◊ô◊ë◊ê◊í ◊ê◊ô◊†◊ì◊ô◊ß◊¶◊ô◊ï◊™ ◊ê◊ù ◊ë◊û◊¶◊ë ◊ì◊ô◊ë◊ê◊í
        if self.debug_mode:
            cv2.putText(frame, f"Fist: {fist_detected}", (10, 300), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)
            cv2.putText(frame, f"Open palm: {open_palm}", (10, 330), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)
            cv2.putText(frame, f"Fingers close: {fingers_close_to_each_other}", (10, 360), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)
            cv2.putText(frame, f"Curled count: {sum([index_curled, middle_curled, ring_curled, pinky_curled])}", (10, 390), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)
            cv2.putText(frame, f"Thumb extended: {thumb_extended}", (10, 420), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)
            cv2.putText(frame, f"Thumb separated: {thumb_clearly_separated}", (10, 450), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)
                
        cv2.putText(frame, f"Gesture: {controls['gesture_name']}", 
                   (frame.shape[1]//2 - 100, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
                
        return controls
    
    def _is_finger_curled(self, finger_tip, finger_mcp, wrist):
        """◊ë◊ì◊ô◊ß◊î ◊û◊©◊ï◊§◊®◊™ ◊ú◊ñ◊ô◊î◊ï◊ô ◊ê◊¶◊ë◊¢ ◊û◊õ◊ï◊§◊§◊™ ◊©◊¢◊ï◊ë◊ì◊™ ◊ë◊õ◊ú ◊ñ◊ï◊ï◊ô◊™ ◊©◊ú ◊î◊ô◊ì"""
        # ◊ó◊ô◊©◊ï◊ë ◊ê◊ï◊®◊ö ◊î◊ê◊¶◊ë◊¢ ◊î◊û◊ß◊°◊ô◊û◊ú◊ô ◊ë◊û◊¶◊ë ◊§◊®◊ï◊©
        max_finger_length = np.sqrt((finger_mcp[0] - wrist[0])**2 + (finger_mcp[1] - wrist[1])**2) * 1.5
        
        # ◊ó◊ô◊©◊ï◊ë ◊î◊û◊®◊ó◊ß ◊ë◊§◊ï◊¢◊ú ◊ë◊ô◊ü ◊ß◊¶◊î ◊î◊ê◊¶◊ë◊¢ ◊ú◊û◊§◊®◊ß
        tip_to_mcp_dist = np.sqrt((finger_tip[0] - finger_mcp[0])**2 + (finger_tip[1] - finger_mcp[1])**2)
        
        # ◊ó◊ô◊©◊ï◊ë ◊û◊®◊ó◊ß ◊û◊û◊®◊õ◊ñ ◊õ◊£ ◊î◊ô◊ì ◊û◊©◊ï◊¢◊®
        palm_center_x = wrist[0] + (finger_mcp[0] - wrist[0]) * 0.4
        palm_center_y = wrist[1] + (finger_mcp[1] - wrist[1]) * 0.4
        tip_to_palm_dist = np.sqrt((finger_tip[0] - palm_center_x)**2 + (finger_tip[1] - palm_center_y)**2)
        
        # ◊ê◊¶◊ë◊¢ ◊û◊õ◊ï◊§◊§◊™ ◊ê◊ù:
        # 1. ◊î◊û◊®◊ó◊ß ◊ë◊ô◊ü ◊î◊ß◊¶◊î ◊ú◊û◊§◊®◊ß ◊ß◊ò◊ü ◊û◊©◊û◊¢◊ï◊™◊ô◊™ ◊û◊î◊ê◊ï◊®◊ö ◊î◊û◊ß◊°◊ô◊û◊ú◊ô ◊î◊ê◊§◊©◊®◊ô, ◊ê◊ï
        # 2. ◊î◊ê◊¶◊ë◊¢ ◊ß◊®◊ï◊ë◊î ◊û◊ê◊ï◊ì ◊ú◊û◊®◊õ◊ñ ◊õ◊£ ◊î◊ô◊ì
        small_extension = tip_to_mcp_dist < max_finger_length * 0.5
        close_to_palm = tip_to_palm_dist < max_finger_length * 0.5
        
        return small_extension or close_to_palm
    
    def _is_finger_extended(self, finger_tip, finger_mcp, wrist):
        """◊ë◊ì◊ô◊ß◊î ◊û◊™◊ß◊ì◊û◊™ ◊î◊ê◊ù ◊î◊ê◊¶◊ë◊¢ ◊û◊ï◊©◊ò◊™"""
        tip_to_mcp = np.sqrt((finger_tip[0] - finger_mcp[0])**2 + (finger_tip[1] - finger_mcp[1])**2)
        mcp_to_wrist = np.sqrt((finger_mcp[0] - wrist[0])**2 + (finger_mcp[1] - wrist[1])**2)
        
        if mcp_to_wrist > 0:
            extension_ratio = tip_to_mcp / mcp_to_wrist
            return extension_ratio > 1.3
        return False
    
    def _is_thumb_extended(self, thumb_tip, thumb_mcp, wrist):
        """
        ◊ë◊ì◊ô◊ß◊î ◊û◊©◊ï◊§◊®◊™ ◊î◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊û◊ï◊ê◊®◊ö, ◊û◊™◊û◊ï◊ì◊ì◊™ ◊¢◊ù ◊ë◊¢◊ô◊ô◊™ ◊ñ◊ô◊î◊ï◊ô ◊í◊ù ◊õ◊©◊î◊ê◊í◊ï◊ì◊ú ◊û◊ï◊°◊™◊®
        """
        # ◊û◊®◊ó◊ß ◊ë◊ô◊ü ◊ß◊¶◊î ◊î◊ê◊í◊ï◊ì◊ú ◊ú◊©◊ï◊®◊© ◊õ◊£ ◊î◊ô◊ì
        tip_to_wrist = np.sqrt((thumb_tip[0] - wrist[0])**2 + (thumb_tip[1] - wrist[1])**2)
        
        # ◊û◊®◊ó◊ß ◊ë◊ô◊ü ◊ë◊°◊ô◊° ◊î◊ê◊í◊ï◊ì◊ú ◊ú◊©◊ï◊®◊© ◊õ◊£ ◊î◊ô◊ì
        mcp_to_wrist = np.sqrt((thumb_mcp[0] - wrist[0])**2 + (thumb_mcp[1] - wrist[1])**2)
        
        # ◊ô◊ó◊° ◊û◊®◊ó◊ß◊ô◊ù - ◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊ë◊ê◊û◊™ ◊û◊ï◊ê◊®◊ö, ◊î◊ß◊¶◊î ◊©◊ú◊ï ◊ê◊û◊ï◊® ◊ú◊î◊ô◊ï◊™ ◊®◊ó◊ï◊ß ◊û◊©◊û◊¢◊ï◊™◊ô◊™ ◊û◊î◊ë◊°◊ô◊°
        distance_ratio = tip_to_wrist / mcp_to_wrist if mcp_to_wrist > 0 else 0
        
        # ◊ï◊ß◊ò◊ï◊® ◊û◊î◊©◊ï◊®◊© ◊ú◊ë◊°◊ô◊° ◊î◊ê◊í◊ï◊ì◊ú
        wrist_to_mcp_x = thumb_mcp[0] - wrist[0]
        wrist_to_mcp_y = thumb_mcp[1] - wrist[1]
        
        # ◊ï◊ß◊ò◊ï◊® ◊û◊ë◊°◊ô◊° ◊î◊ê◊í◊ï◊ì◊ú ◊ú◊ß◊¶◊î ◊î◊ê◊í◊ï◊ì◊ú
        mcp_to_tip_x = thumb_tip[0] - thumb_mcp[0]
        mcp_to_tip_y = thumb_tip[1] - thumb_mcp[1]
        
        # ◊ó◊ô◊©◊ï◊ë ◊û◊õ◊§◊ú◊î ◊°◊ß◊ú◊®◊ô◊™ (◊ì◊ï◊ò ◊§◊®◊ï◊ì◊ß◊ò)
        dot_product = wrist_to_mcp_x * mcp_to_tip_x + wrist_to_mcp_y * mcp_to_tip_y
        
        # ◊ó◊ô◊©◊ï◊ë ◊í◊ï◊ì◊ú ◊î◊ï◊ï◊ß◊ò◊ï◊®◊ô◊ù
        wrist_to_mcp_length = np.sqrt(wrist_to_mcp_x**2 + wrist_to_mcp_y**2)
        mcp_to_tip_length = np.sqrt(mcp_to_tip_x**2 + mcp_to_tip_y**2)
        
        # ◊ë◊ì◊ô◊ß◊î ◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊†◊û◊¶◊ê ◊ë◊¶◊ì ◊î◊û◊™◊ê◊ô◊ù ◊©◊ú ◊õ◊£ ◊î◊ô◊ì
        # ◊õ◊ú◊ï◊û◊®, ◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊ë◊ê◊û◊™ ◊ô◊ï◊¶◊ê ◊î◊ó◊ï◊¶◊î ◊ê◊ï ◊©◊î◊ï◊ê ◊û◊ï◊°◊™◊®/◊û◊õ◊ï◊§◊£
        thumb_position_x_relative = thumb_tip[0] - wrist[0]  # ◊û◊ô◊ß◊ï◊ù ◊ê◊ï◊§◊ß◊ô ◊ô◊ó◊°◊ô ◊ú◊©◊ï◊®◊© ◊õ◊£ ◊î◊ô◊ì
        
        # ◊í◊ù ◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊û◊ï◊°◊™◊®, ◊î◊ï◊ê ◊ë◊ì◊®◊ö ◊õ◊ú◊ú ◊¢◊ì◊ô◊ô◊ü ◊ß◊®◊ï◊ë ◊ú◊õ◊£ ◊î◊ô◊ì
        thumb_close_to_palm = tip_to_wrist < 1.7 * mcp_to_wrist
        
        # ◊ë◊ì◊ô◊ß◊î ◊û◊©◊ï◊§◊®◊™ ◊î◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊ë◊ê◊û◊™ ◊û◊ï◊ê◊®◊ö
        if wrist_to_mcp_length > 0 and mcp_to_tip_length > 0:
            cos_angle = dot_product / (wrist_to_mcp_length * mcp_to_tip_length)
            cos_angle = max(min(cos_angle, 1.0), -1.0)  # ◊î◊í◊ë◊ú◊î ◊ú◊û◊†◊ï◊¢ ◊©◊í◊ô◊ê◊ï◊™ ◊û◊°◊§◊®◊ô◊ï◊™
            angle = np.degrees(np.arccos(cos_angle))
            
            # ◊î◊ê◊í◊ï◊ì◊ú ◊†◊ó◊©◊ë ◊û◊ï◊ê◊®◊ö ◊®◊ß ◊ê◊ù:
            # 1. ◊î◊ñ◊ï◊ï◊ô◊™ ◊ë◊ô◊ü ◊î◊ï◊ï◊ß◊ò◊ï◊®◊ô◊ù ◊í◊ì◊ï◊ú◊î ◊û◊°◊§◊ô◊ß (◊ê◊í◊ï◊ì◊ú ◊§◊ï◊†◊î ◊ú◊õ◊ô◊ï◊ï◊ü ◊©◊ï◊†◊î ◊û◊î◊ô◊ì)
            # 2. ◊î◊ô◊ó◊° ◊ë◊ô◊ü ◊î◊û◊®◊ó◊ß◊ô◊ù ◊û◊¢◊ô◊ì ◊¢◊ú ◊ê◊í◊ï◊ì◊ú ◊û◊ï◊©◊ò
            # 3. ◊î◊ê◊í◊ï◊ì◊ú ◊ú◊ê ◊ß◊®◊ï◊ë ◊û◊ì◊ô ◊ú◊õ◊£ ◊î◊ô◊ì (◊ê◊ó◊®◊™ ◊î◊ï◊ê ◊õ◊†◊®◊ê◊î ◊û◊ï◊°◊™◊®)
            thumb_extended = (angle > 60 and           # ◊ñ◊ï◊ï◊ô◊™ ◊í◊ì◊ï◊ú◊î ◊ë◊ô◊ü ◊î◊©◊ï◊®◊© ◊ú◊ê◊ê◊í◊ï◊ì◊ú
                             distance_ratio > 1.5 and  # ◊ß◊¶◊î ◊î◊ê◊í◊ï◊ì◊ú ◊®◊ó◊ï◊ß ◊ô◊ï◊™◊® ◊û◊î◊ë◊°◊ô◊°
                             not thumb_close_to_palm)  # ◊î◊ê◊í◊ï◊ì◊ú ◊ú◊ê ◊¶◊û◊ï◊ì/◊û◊ï◊°◊™◊® ◊ë◊õ◊£ ◊î◊ô◊ì
            
            return thumb_extended
        
        return False
    
    def _is_thumb_extended_improved(self, thumb_tip, thumb_mcp, wrist):
        """
        ◊í◊®◊°◊î ◊û◊©◊ï◊§◊®◊™ ◊©◊ú ◊ë◊ì◊ô◊ß◊™ ◊î◊ê◊í◊ï◊ì◊ú ◊î◊û◊ï◊ê◊®◊ö, ◊î◊û◊™◊ó◊©◊ë◊™ ◊ë◊ñ◊ï◊ï◊ô◊ï◊™ ◊©◊ï◊†◊ï◊™ ◊ï◊û◊¶◊ë◊ô◊ù ◊©◊ï◊†◊ô◊ù ◊©◊ú ◊î◊ê◊í◊ï◊ì◊ú.
        """
        # ◊û◊®◊ó◊ß ◊ë◊ô◊ü ◊ß◊¶◊î ◊î◊ê◊í◊ï◊ì◊ú ◊ú◊©◊ï◊®◊© ◊õ◊£ ◊î◊ô◊ì
        tip_to_wrist = np.sqrt((thumb_tip[0] - wrist[0])**2 + (thumb_tip[1] - wrist[1])**2)
        
        # ◊û◊®◊ó◊ß ◊ë◊ô◊ü ◊ë◊°◊ô◊° ◊î◊ê◊í◊ï◊ì◊ú ◊ú◊©◊ï◊®◊© ◊õ◊£ ◊î◊ô◊ì
        mcp_to_wrist = np.sqrt((thumb_mcp[0] - wrist[0])**2 + (thumb_mcp[1] - wrist[1])**2)
        
        # ◊û◊®◊ó◊ß ◊ë◊ô◊ü ◊ß◊¶◊î ◊î◊ê◊í◊ï◊ì◊ú ◊ú◊ë◊°◊ô◊° ◊î◊ê◊í◊ï◊ì◊ú
        tip_to_mcp = np.sqrt((thumb_tip[0] - thumb_mcp[0])**2 + (thumb_tip[1] - thumb_mcp[1])**2)
        
        # ◊ë◊ì◊ô◊ß◊î 1: ◊î◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊†◊û◊¶◊ê ◊ë◊ß◊¶◊î ◊î◊ó◊ô◊¶◊ï◊†◊ô ◊©◊ú ◊õ◊£ ◊î◊ô◊ì (◊ë◊î◊™◊ê◊ù ◊ú◊™◊û◊ï◊†◊î)
        thumb_outside_palm = (thumb_tip[0] - wrist[0]) * (thumb_mcp[0] - wrist[0]) > 0  # ◊î◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊ë◊õ◊ô◊ï◊ï◊ü ◊î◊†◊õ◊ï◊ü
        
        # ◊ë◊ì◊ô◊ß◊î 2: ◊î◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊ê◊®◊ï◊ö ◊û◊°◊§◊ô◊ß ◊ë◊ô◊ó◊° ◊ú◊õ◊£ ◊î◊ô◊ì
        extended_length = tip_to_mcp > 0.5 * mcp_to_wrist
        
        # ◊ë◊ì◊ô◊ß◊î 3: ◊î◊ê◊ù ◊î◊ê◊í◊ï◊ì◊ú ◊®◊ó◊ï◊ß ◊û◊°◊§◊ô◊ß ◊û◊©◊ï◊®◊© ◊õ◊£ ◊î◊ô◊ì
        away_from_wrist = tip_to_wrist > 1.2 * mcp_to_wrist
        
        # ◊ñ◊ô◊î◊ï◊ô ◊û◊©◊ï◊§◊® - ◊î◊ê◊í◊ï◊ì◊ú ◊û◊ï◊ê◊®◊ö ◊ê◊ù ◊î◊ï◊ê ◊¢◊ï◊û◊ì ◊ë◊ó◊ú◊ß ◊û◊î◊™◊†◊ê◊ô◊ù
        thumb_extended = (thumb_outside_palm and extended_length) or away_from_wrist
        
        return thumb_extended
        
    def _update_command_stability(self, command):
        if command == self.last_command:
            self.command_stability_count += 1
        else:
            self.last_command = command
            self.command_stability_count = 1
            
    def get_stable_command(self):
        if self.command_stability_count >= self.stability_threshold:
            return self.last_command
        return None

    def _add_control_visualization(self, frame, controls):
        h, w, _ = frame.shape
        
        panel_height = 120
        panel_y = h - panel_height - 10
        panel_width = 250
        cv2.rectangle(frame, (10, panel_y), (panel_width + 10, h - 10), (230, 230, 230), -1)
        cv2.rectangle(frame, (10, panel_y), (panel_width + 10, h - 10), (0, 0, 0), 1)
        
        steering = controls['steering']
        cv2.putText(frame, "Steering:", (20, panel_y + 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 0), 2)
        
        steer_center_x = 130
        steer_width = 100
        steer_y = panel_y + 30
        
        cv2.rectangle(frame, 
                      (steer_center_x - steer_width//2, steer_y - 15), 
                      (steer_center_x + steer_width//2, steer_y + 15), 
                      (200, 200, 200), -1)
        cv2.rectangle(frame, 
                      (steer_center_x - steer_width//2, steer_y - 15), 
                      (steer_center_x + steer_width//2, steer_y + 15), 
                      (0, 0, 0), 1)
        
        steer_pos = int(steer_center_x + steering * steer_width/2)
        cv2.circle(frame, (steer_pos, steer_y), 10, (0, 0, 255), -1)
        
        throttle = controls['throttle']
        cv2.putText(frame, "Throttle:", (20, panel_y + 70), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 0), 2)
        
        throttle_x = 130
        throttle_height = 50
        throttle_width = 30
        throttle_y = panel_y + 50
        
        cv2.rectangle(frame, 
                     (throttle_x, throttle_y), 
                     (throttle_x + throttle_width, throttle_y + throttle_height), 
                     (200, 200, 200), -1)
        cv2.rectangle(frame, 
                     (throttle_x, throttle_y), 
                     (throttle_x + throttle_width, throttle_y + throttle_height), 
                     (0, 0, 0), 1)
        
        filled_height = int(throttle_height * throttle)
        cv2.rectangle(frame, 
                     (throttle_x, throttle_y + throttle_height - filled_height), 
                     (throttle_x + throttle_width, throttle_y + throttle_height), 
                     (0, 255, 0), -1)
        
        brake_color = (0, 0, 255) if controls['braking'] else (200, 200, 200)
        cv2.circle(frame, (50, panel_y + 110), 15, brake_color, -1)
        cv2.putText(frame, "Brake", (30, panel_y + 140), cv2.FONT_HERSHEY_SIMPLEX, 0.6, brake_color, 2)
        
        boost_color = (255, 165, 0) if controls['boost'] else (200, 200, 200)
        cv2.circle(frame, (120, panel_y + 110), 15, boost_color, -1)
        cv2.putText(frame, "Boost", (100, panel_y + 140), cv2.FONT_HERSHEY_SIMPLEX, 0.6, boost_color, 2)
        
        stability_x = panel_width - 40
        cv2.putText(frame, f"Stability: {self.command_stability_count}/{self.stability_threshold}", 
                   (stability_x - 80, panel_y + 110), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1)